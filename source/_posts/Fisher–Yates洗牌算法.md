---
title: Fisher–Yates洗牌算法
date: 2020-01-15 10:36:23
tags:
- 算法
---
洗牌算法这个问题可以看作是一个概率问题，不妨先看这样一个简单的问题：
**1-100这100个数字落在一个数组里，如何随机从中取出一个数呢？**
直接使用Random函数返回一个数组下标，取到对应的值即可。
那么将这个问题改一改，**如果是随机取出50个数呢**？注意我们取数一定是不能重复的，如果按照Random的方法循环50次，就会带来一个问题：随着Random的次数越来越多，取到相同数字的概率会越来越大，每次取到相同的数就要丢掉再次Random直到取到不重复的数为止。
这种暴力算法随着取数的规模扩大，显然效率会指数性的下降。是否有一种算法能够确保每个数被取到的概率是相等的且比较高效呢？Fisher–Yates Shuffle
# Fisher-Yates
```js
...{
    for(int i=suit.length-1;i>0;i--)
    {
        random1 = Random.next(1,i);
        exchange(suit[random1],suit[i]);
    }
}...
```
这个算法不但效率很高而且非常优雅，整个逻辑非常简单：
取0～i-1索引的一个随机数random1，交换suit[i]与suit[random1]的值，循环此步骤生成的序列就是一个随机序列。
Fisher–Yates算法在原理上保证了不会出现浪费次数，重复选择的情况，导致样本空间一直保持n！，没有坍缩；代码精简优雅，体现了算法和数学之美。
它的随机性也很好证明，一个元素k被放入第i个位置的概率P = 前i-1个位置选择元素时没有选中k的概率 * 第i个位置选中m的概率*
![][image-1]

[image-1]:	https://myblog-1259548259.cos.ap-beijing.myqcloud.com/fisher_yates.png