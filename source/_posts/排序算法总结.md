---
title: 排序算法总结
date: 2020-10-08 20:45:59
tags:
- 算法
mathjax: true
---
排序几乎是每个程序员算法的入门，在平时的工作中，排序几乎无处不在。熟练掌握各种排序算法的原理、时间/空间复杂度可以说是程序员重要的一项基本功，通常也是各个公司面试官非常喜爱考察的问题。
本文试图总结常见的排序算法原理、代码、时间/空间复杂度，以及这些算法应用的一些思考。
# 快速排序
一种典型分治思想的排序算法。其基本流程是
- 取数组中的第一个元素（随机化快排随机选取数组中的一个节点）
- 遍历数组，将小于该元素值的元素置于该元素左侧，其他元素置于该元素右侧
- 递归对左右侧子数组进行相同处理
```js
    public void quicksort(int[] a, int begin, int end) {
        if (begin >= end) return;
        int temp = a[begin];
        int key = begin;
        for (int j = begin + 1; j <= end; j++) {
            if (a[j] < temp) {
                swap(a, key + 1, j);
                key++;
            }
        }
        swap(a, begin, key);
        quicksort(a, begin, key - 1);
        quicksort(a, key + 1, end);
    }
```
## 快速排序的时间复杂度
理想状态下，每个选择出来的元素刚好能将数组切分成大小相同的两个子数组，那么递推公式就是：
```js
T(n) = 2 * T(n/2) + n
```
推导可得时间复杂度为O(n$\log(n)$)，但在最糟糕的情况，即数组本身就是有序的情况下，会退化成O($n^{2}$)，但是这种情况可以通过随机化快排的方式来进行规避，但在实际情况中，这种极端情况极少出现，同时也可以采用随机化的方式来进行规避，因此快速排序可以说是一个非常优秀的排序算法。（其实，只要是非极端情况，如选中的元素将数组切分成1:9两部分，那快速排序的时间复杂度依然是O(n$\log(n)$)）
## 快速排序是否是稳定排序？
显然不是，快速排序是随机选中数组中的一个元素，考虑这样一个数组{1,2,3,9,8,11,8}，选中最后一个8作为比对元素，那么这个8会被放置在索引3的位置，这样就和索引4的8的前后顺序发生了变更。
## 快速排序的空间复杂度
快排是一种原地排序算法，空间复杂度为O(1)。
# 归并排序
归并排序同样是利用分治思想的排序算法，其思想是：将数组从中间分成前后两部分，对两部分分别排序，再对两个有序数组进行合并排序，这样整个数组就是有序的了。
```js
    public void mergesort(int[] a, int begin, int end) {
        if (begin >= end) return;
        int mid = (begin + end) / 2;
        mergesort(a, begin, mid);
        mergesort(a, mid + 1, end);
        merge(a, begin, mid, end);
    }

    public void merge(int[] a, int begin, int mid, int end) {
        int[] temp = new int[end - begin + 1];
        int i = begin, j = mid + 1, k = 0;
        while (i <= mid && j <= end) {
            if (a[i] < a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }
        while (i <= mid) {
            temp[k++] = a[i++];
        }
        while (j <= end) {
            temp[k++] = a[j++];
        }
        for (int m = 0; m < temp.length; m++) {
            a[m + begin] = temp[m];
        }
    }
```
## 归并排序的时间复杂度
与快速排序类似的，归并排序的时间复杂度可以由以下递推公式推得：
```js
T(n) = 2 * T(n/2) + n
```
即处理左右两个子数组的时间复杂度+合并两个子数组的时间，因此，归并排序的时间复杂度是O(n$\log(n)$)。
## 归并排序是稳定排序么？
我们在merge的过程中，只要保证先将左边数组的元素放入temp数组，就可以保证值相同的元素在排序后依然保持先后顺序不变，因此归并排序是稳定排序。
## 归并排序的空间复杂度
归并排序需要借助一个temp数组来实现合并排序，虽然在递归过程中会申请很多临时数组，但在合并后，这个临时数组就被释放了，因此实际申请的最大空间也不会超过n个数据，空间复杂度为O(n)。
归并排序从时间复杂度来看，是一个非常优秀的排序算法，然而相比于快速排序和堆排序，归并排序在实际场景中很少被使用，个人认为主要原因是：
- 有额外的空间开销，排序100M的数据，额外占用100M空间
- 代码本身比较复杂，实际运行时不会十分高效 
# 堆排序
堆排序的思想是利用大（小）顶堆的性质来进行排序，首先将原数组构造成一个大顶堆，每次交换堆顶元素和尾部元素，再重新构建大顶堆。
```js
public void heapsort(int[] a)
{
    int length=a.length;
    for(int i=(length-1)/2;i>=0;i--)
    {
        sink(a,i,length-1);
    }
    int n=length-1;
    while(n>0){
        swap(a,n--,0);
        sink(a,0,n);
    }
}
public void sink(int[] a,int k,int n)
{

    while(2*k+1<=n)
    {
        int j=2*k+1;
        if(j<n&&a[j]<a[j+1])
            j++;
        if(a[k]>a[j]) break;
        swap(a,j,k);
        k=j;
    }
}
```

## 堆排序的时间复杂度
堆排序的流程可以分为两步：
1. 构建大顶堆
2. 排序重建堆

其中，初始化构建大顶堆的时间复杂度为O(n)，而排序堆重建每次重建的复杂度为O(logn)，因此时间复杂度为：
O(n)+O(n\*logn) = O(nlogn)* ## 堆排序是稳定排序么？
显然不是，在构建大顶堆的时候，相等元素可能会调整顺序，因此堆排序不是一种稳定的排序。
## 堆排序的空间复杂度
堆排序是一种原地排序，不需要额外的空间开销，空间复杂度为O(1)。
堆排序无论从空间还是时间性能来看，都是一种很优秀的排序算法，但是在实际生产环境中，堆排序的应用并不广泛。最重要的原因是现代CPU的高速缓存架构导致堆排序这种跳跃数组遍历的方式无法充分利用CPU高速缓存，因而在实际应用中通常性能并不如快速排序和插入排序。
未完待续….