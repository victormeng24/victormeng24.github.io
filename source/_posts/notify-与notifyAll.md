---
title: notify()与notifyAll()
date: 2020-06-02 14:54:58
tags:
- 线程
- Java
---
谈notify()与notifyAll()之前，需要明确锁池和等待池两个概念：
锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中
- 当一个线程调用wait()时，代表让出持有的对象锁，同时自身进入等待池，处于等待池的线程不会去竞争对象锁
- 当一个线程调用notify()或者notifyAll()时，前者会从等待池中随机选择一个线程进入锁池来竞争对象锁，而后者会将等待池中的全部线程放入锁池中，这就是notify()和notifyAll()的区别
- 从notify()和notifyAll()的作用来看，理想状态下，竞争锁的线程应当具有相同的职能，否则会造成无用的开销甚至死锁（一个典型的死锁场景会在后面介绍）。如果需要对不同角色的线程进行类似wait&notify的控制，可以使用Lock&Condition来实现
关于nofify()产生死锁的场景，可以想象一个典型的多生产者消费者的场景：
生产者、消费者数量都为2，缓冲区为1，当按照下列并发顺序执行的时候出现死锁：
1.消费者1获得锁，发现缓冲区为0，wait（wait自动释放锁）（等待池：消费者1 锁池：消费者2、生产者1、生产者2）
2.消费者2获得锁，发现缓冲区为0，wait（wait自动释放锁）（等待池：消费者1、消费者2  锁池：生产者1、生产者2）
3.生产者1获得锁，发现缓冲区为0可以生产，生产以后放在缓冲区，notify，现在缓冲区为1（等待池：消费者1、消费者2  锁池：生产者2）
4.第3步notify唤醒了消费者1，但是消费者1没有抢到锁，锁被生产者2拿到了；（等待池：消费者2  锁池：消费者1）
5.生产者2发现缓冲区为1（因为只是唤醒了消费者1，但是消费者1没有抢到锁，没法消费），wait（wait自动释放锁）；（等待池：消费者2 、生产者2 锁池：消费者1）
6.消费者1获得了锁，消费并且notify（此时生产者2和消费者2都处于wait状态），缓冲区为0；（等待池：消费者2 、生产者2 锁池：）
7.notify唤醒了消费者2，消费者2醒来后拿到锁发现缓冲区为0，接着wait，与此同时，生产者2也在wait，死锁产生。
造成这种情况的原因是：
1. 被notify()的线程不能保证持有锁
2. notify()可能唤醒同一角色的线程