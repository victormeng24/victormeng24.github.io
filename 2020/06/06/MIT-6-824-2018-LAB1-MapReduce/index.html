<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="6.824，MIT的神课之一，转Golang的机会正好作为一次练习。目前Lab1已经刷完，感觉还是很有收获，尤其是踩了些Go的坑，Github地址。 Part I The Map&#x2F;Reduce implementation you are given is missing some pieces. Before you can write your first Map&#x2F;Reduce functio">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT-6.824-2018-LAB1-MapReduce">
<meta property="og:url" content="http://example.com/2020/06/06/MIT-6-824-2018-LAB1-MapReduce/index.html">
<meta property="og:site_name" content="怒吃树的博客">
<meta property="og:description" content="6.824，MIT的神课之一，转Golang的机会正好作为一次练习。目前Lab1已经刷完，感觉还是很有收获，尤其是踩了些Go的坑，Github地址。 Part I The Map&#x2F;Reduce implementation you are given is missing some pieces. Before you can write your first Map&#x2F;Reduce functio">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-06T04:30:16.000Z">
<meta property="article:modified_time" content="2020-10-08T11:38:11.540Z">
<meta property="article:author" content="Roger Meng">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/06/06/MIT-6-824-2018-LAB1-MapReduce/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>MIT-6.824-2018-LAB1-MapReduce | 怒吃树的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">怒吃树的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/MIT-6-824-2018-LAB1-MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT-6.824-2018-LAB1-MapReduce
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-06 12:30:16" itemprop="dateCreated datePublished" datetime="2020-06-06T12:30:16+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>6.824，MIT的神课之一，转Golang的机会正好作为一次练习。目前Lab1已经刷完，感觉还是很有收获，尤其是踩了些Go的坑，<a target="_blank" rel="noopener" href="https://github.com/victormeng24/6.824" title="Github地址">Github地址</a>。</p>
<h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><blockquote>
<p>The Map/Reduce implementation you are given is missing some pieces. Before you can write your first Map/Reduce function pair, you will need to fix the sequential implementation. In particular, the code we give you is missing two crucial pieces: the function that divides up the output of a map task, and the function that gathers all the inputs for a reduce task. These tasks are carried out by the doMap() function in common_map.go, and the doReduce() function in common_reduce.go respectively. The comments in those files should point you in the right direction.</p>
<p>To help you determine if you have correctly implemented doMap() and doReduce(), we have provided you with a Go test suite that checks the correctness of your implementation. These tests are implemented in the file test_test.go. To run the tests for the sequential implementation that you have now fixed, run:_</p>
</blockquote>
<p>PartI是对Map/Reduce function的一个简单实现（不是具体的Mr逻辑，而是对于文件操作的骨架实现），主要是帮助你熟悉Golang的一些对于文件IO的语法，整体没有太大难度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">func doMap(</span><br><span class="line">	jobName string, <span class="comment">// the name of the MapReduce job</span></span><br><span class="line">	mapTask int,    <span class="comment">// which map task this is</span></span><br><span class="line">	inFile string,</span><br><span class="line">	nReduce int, <span class="comment">// the number of reduce task that will be run (&quot;R&quot; in the paper)</span></span><br><span class="line">	mapF func(filename string, contents string) []KeyValue,</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// doMap manages one map task: it should read one of the input files</span></span><br><span class="line">	<span class="comment">// (inFile), call the user-defined map function (mapF) for that file&#x27;s</span></span><br><span class="line">	<span class="comment">// contents, and partition mapF&#x27;s output into nReduce intermediate files.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// There is one intermediate file per reduce task. The file name</span></span><br><span class="line">	<span class="comment">// includes both the map task number and the reduce task number. Use</span></span><br><span class="line">	<span class="comment">// the filename generated by reduceName(jobName, mapTask, r)</span></span><br><span class="line">	<span class="comment">// as the intermediate file for reduce task r. Call ihash() (see</span></span><br><span class="line">	<span class="comment">// below) on each key, mod nReduce, to pick r for a key/value pair.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// mapF() is the map function provided by the application. The first</span></span><br><span class="line">	<span class="comment">// argument should be the input file name, though the map function</span></span><br><span class="line">	<span class="comment">// typically ignores it. The second argument should be the entire</span></span><br><span class="line">	<span class="comment">// input file contents. mapF() returns a slice containing the</span></span><br><span class="line">	<span class="comment">// key/value pairs for reduce; see common.go for the definition of</span></span><br><span class="line">	<span class="comment">// KeyValue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Look at Go&#x27;s ioutil and os packages for functions to read</span></span><br><span class="line">	<span class="comment">// and write files.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Coming up with a scheme for how to format the key/value pairs on</span></span><br><span class="line">	<span class="comment">// disk can be tricky, especially when taking into account that both</span></span><br><span class="line">	<span class="comment">// keys and values could contain newlines, quotes, and any other</span></span><br><span class="line">	<span class="comment">// character you can think of.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// One format often used for serializing data to a byte stream that the</span></span><br><span class="line">	<span class="comment">// other end can correctly reconstruct is JSON. You are not required to</span></span><br><span class="line">	<span class="comment">// use JSON, but as the output of the reduce tasks *must* be JSON,</span></span><br><span class="line">	<span class="comment">// familiarizing yourself with it here may prove useful. You can write</span></span><br><span class="line">	<span class="comment">// out a data structure as a JSON string to a file using the commented</span></span><br><span class="line">	<span class="comment">// code below. The corresponding decoding functions can be found in</span></span><br><span class="line">	<span class="comment">// common_reduce.go.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   enc := json.NewEncoder(file)</span></span><br><span class="line">	<span class="comment">//   for _, kv := ... &#123;</span></span><br><span class="line">	<span class="comment">//     err := enc.Encode(&amp;kv)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Remember to close the file after you have written all the values!</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part I).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	content, <span class="attr">err</span> := ioutil.ReadFile(inFile)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	keyValue := mapF(inFile, string(content))</span><br><span class="line">	mapper := make([][]KeyValue, nReduce)</span><br><span class="line">	<span class="comment">// determine to which reducer</span></span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">v</span> := range keyValue &#123;</span><br><span class="line">		idx := ihash(v.Key) % nReduce</span><br><span class="line">		mapper[idx] = append(mapper[idx], v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write to target File</span></span><br><span class="line">	<span class="keyword">for</span> index, <span class="attr">v</span> := range mapper &#123;</span><br><span class="line">		targetFileName := reduceName(jobName, mapTask, index)</span><br><span class="line">		fileNameToChoose, <span class="attr">err</span> := os.Create(targetFileName)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		ret, <span class="attr">err</span> := json.Marshal(v)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fileNameToChoose.Write(ret)</span><br><span class="line">		fileNameToChoose.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func doReduce(</span><br><span class="line">	jobName string, <span class="comment">// the name of the whole MapReduce job</span></span><br><span class="line">	reduceTask int, <span class="comment">// which reduce task this is</span></span><br><span class="line">	outFile string, <span class="comment">// write the output here</span></span><br><span class="line">	nMap int,       <span class="comment">// the number of map tasks that were run (&quot;M&quot; in the paper)</span></span><br><span class="line">	reduceF func(key string, values []string) string,</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// doReduce manages one reduce task: it should read the intermediate</span></span><br><span class="line">	<span class="comment">// files for the task, sort the intermediate key/value pairs by key,</span></span><br><span class="line">	<span class="comment">// call the user-defined reduce function (reduceF) for each key, and</span></span><br><span class="line">	<span class="comment">// write reduceF&#x27;s output to disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You&#x27;ll need to read one intermediate file from each map task;</span></span><br><span class="line">	<span class="comment">// reduceName(jobName, m, reduceTask) yields the file</span></span><br><span class="line">	<span class="comment">// name from map task m.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your doMap() encoded the key/value pairs in the intermediate</span></span><br><span class="line">	<span class="comment">// files, so you will need to decode them. If you used JSON, you can</span></span><br><span class="line">	<span class="comment">// read and decode by creating a decoder and repeatedly calling</span></span><br><span class="line">	<span class="comment">// .Decode(&amp;kv) on it until it returns an error.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You may find the first example in the golang sort package</span></span><br><span class="line">	<span class="comment">// documentation useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// reduceF() is the application&#x27;s reduce function. You should</span></span><br><span class="line">	<span class="comment">// call it once per distinct key, with a slice of all the values</span></span><br><span class="line">	<span class="comment">// for that key. reduceF() returns the reduced value for that key.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You should write the reduce output as JSON encoded KeyValue</span></span><br><span class="line">	<span class="comment">// objects to the file named outFile. We require you to use JSON</span></span><br><span class="line">	<span class="comment">// because that is what the merger than combines the output</span></span><br><span class="line">	<span class="comment">// from all the reduce tasks expects. There is nothing special about</span></span><br><span class="line">	<span class="comment">// JSON -- it is just the marshalling format we chose to use. Your</span></span><br><span class="line">	<span class="comment">// output code will look something like this:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// enc := json.NewEncoder(file)</span></span><br><span class="line">	<span class="comment">// for key := ... &#123;</span></span><br><span class="line">	<span class="comment">// 	enc.Encode(KeyValue&#123;key, reduceF(...)&#125;)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// file.Close()</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part I).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	keyV := make(map[string][]string)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">		mapFileName := reduceName(jobName, i, reduceTask)</span><br><span class="line">		input, <span class="attr">err</span> := ioutil.ReadFile(mapFileName)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> tmpKeyv []KeyValue</span><br><span class="line">		json.Unmarshal(input, &amp;tmpKeyv)</span><br><span class="line">		<span class="keyword">for</span> _, <span class="attr">v</span> := range tmpKeyv &#123;</span><br><span class="line">			keyV[v.Key] = append(keyV[v.Key], v.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outputFile, <span class="attr">err</span> := os.Create(outFile)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enc := json.NewEncoder(outputFile)</span><br><span class="line">	<span class="keyword">for</span> key, <span class="attr">value</span> := range keyV &#123;</span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(KeyValue&#123;key, reduceF(key, value)&#125;); err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := outputFile.Close(); err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><blockquote>
<p>Now you will implement word count — a simple Map/Reduce example. Look in main/wc.go; you’ll find empty mapF() and reduceF() functions. Your job is to insert code so that wc.go reports the number of occurrences of each word in its input. A word is any contiguous sequence of letters, as determined by unicode.IsLetter.</p>
</blockquote>
<p>实现一个WordCount的mr function，其实也很简单，主要是熟悉一下Golang的api-&gt;如何将一篇文章拆分成string的slice？strings. FieldsFunc(s string, f func(rune) bool)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func mapF(filename string, contents string) []mapreduce.KeyValue &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	strArr := strings.FieldsFunc(contents, func(r rune) bool &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">	&#125;)</span><br><span class="line">	ret := make([]mapreduce.KeyValue, <span class="number">0</span>, len(strArr))</span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">str</span> := range strArr &#123;</span><br><span class="line">		kv := mapreduce.KeyValue&#123;<span class="attr">Key</span>: str, <span class="attr">Value</span>: <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">		ret = append(ret, kv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">func reduceF(key string, values []string) string &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, len(values))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Part-III-amp-IV"><a href="#Part-III-amp-IV" class="headerlink" title="Part III&amp;IV"></a>Part III&amp;IV</h1><blockquote>
<p>Your current implementation runs the map and reduce tasks one at a time. One of Map/Reduce’s biggest selling points is that it can automatically parallelize ordinary sequential code without any extra work by the developer. In this part of the lab, you will complete a version of MapReduce that splits the work over a set of worker threads that run in parallel on multiple cores. While not distributed across multiple machines as in real Map/Reduce deployments, your implementation will use RPC to simulate distributed computation.<br>In this part you will make the master handle failed workers. MapReduce makes this relatively easy because workers don’t have persistent state. If a worker fails while handling an RPC from the master, the master’s call() will eventually return false due to a timeout. In that situation, the master should re-assign the task given to the failed worker to another worker.</p>
</blockquote>
<blockquote>
<p>An RPC failure doesn’t necessarily mean that the worker didn’t execute the task; the worker may have executed it but the reply was lost, or the worker may still be executing but the master’s RPC timed out. Thus, it may happen that two workers receive the same task, compute it, and generate output. Two invocations of a map or reduce function are required to generate the same output for a given input (i.e. the map and reduce functions are “functional”), so there won’t be inconsistencies if subsequent processing sometimes reads one output and sometimes the other. In addition, the MapReduce framework ensures that map and reduce function output appears atomically: the output file will either not exist, or will contain the entire output of a single execution of the map or reduce function (the lab code doesn’t actually implement this, but instead only fails workers at the end of a task, so there aren’t concurrent executions of a task).</p>
</blockquote>
<p>Part III和Part IV，如果你对Goroutine和Channel不是很了解的话，实现起来就有难度了。PartIII是实现一个Mr的分布式调度器schedule()，RPC通信的框架和Worker的DoTask课程都为我们实现了，我们需要考虑的就是Master节点如何调度Worker完成具体的作业，以及（PartIV）当Worker Failure了之后如何实现高可用（将分配给该Worker的任务重新分配给另一个Worker）。实现要求我们只改动schedule.go中的schedule() function：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks int</span><br><span class="line">	<span class="keyword">var</span> n_other int <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = len(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = len(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;</span>, ntasks, phase, n_other)</span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		args := &amp;DoTaskArgs&#123;</span><br><span class="line">			JobName:       jobName,</span><br><span class="line">			File:          mapFiles[i],</span><br><span class="line">			Phase:         phase,</span><br><span class="line">			TaskNumber:    i,</span><br><span class="line">			NumOtherPhase: n_other&#125;</span><br><span class="line">		go func(ch chan string, args *DoTaskArgs) &#123;</span><br><span class="line">			worker := <span class="xml"><span class="tag">&lt;<span class="name">-registerChan</span></span></span></span><br><span class="line"><span class="xml">			for !call(worker, &quot;Worker.DoTask&quot;, args, nil) &#123;</span></span><br><span class="line">				worker = &lt;-registerChan</span><br><span class="line">			&#125;</span><br><span class="line">			// start a goroutine to avoid block</span><br><span class="line">			go func() &#123;</span><br><span class="line">				registerChan &lt;- worker</span><br><span class="line">			&#125;()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(registerChan, args)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(&quot;Schedule: %v done\n&quot;, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是通过一个Channel对可用的Worker进行控制，调度任务时首先获取Worker，任务执行完毕后释放Worker。当Worker任务执行失败时重新选择一个可用的Worker。<br>需要注意的是任务执行完毕后为什么要启动另一个goroutine来释放worker呢？因为registerChan &lt;- worker是一个阻塞操作，当channel中有worker的时候会阻塞在这里导致主函数无法继续执行。</p>
<h1 id="Part-V"><a href="#Part-V" class="headerlink" title="Part V"></a>Part V</h1><blockquote>
<p>For this optional no-credit exercise, you will build Map and Reduce functions for generating an inverted index.</p>
<p>Inverted indices are widely used in computer science, and are particularly useful in document searching. Broadly speaking, an inverted index is a map from interesting facts about the underlying data, to the original location of that data. For example, in the context of search, it might be a map from keywords to documents that contain those words.</p>
<p>We have created a second binary in main/ii.go that is very similar to the wc.go you built earlier. You should modify mapF and reduceF in main/ii.go so that they together produce an inverted index. Running ii.go should output a list of tuples, one per line, in the following format:</p>
</blockquote>
<p>可选题，写的Challenge其实我觉得比3、4简单很多。。实现一个倒排索引，统计单词出现在几篇文章中以及这些文章的list，和PartII的逻辑基本没什么区别，加一个map实现去重即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The mapping function is called once for each piece of the input.</span></span><br><span class="line"><span class="comment">// In this framework, the key is the name of the file that is being processed,</span></span><br><span class="line"><span class="comment">// and the value is the file&#x27;s contents. The return value should be a slice of</span></span><br><span class="line"><span class="comment">// key/value pairs, each represented by a mapreduce.KeyValue.</span></span><br><span class="line">func mapF(<span class="built_in">document</span> string, value string) (res []mapreduce.KeyValue) &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		slice []string</span><br><span class="line">		mp    map[string]string</span><br><span class="line">		ret   []mapreduce.KeyValue</span><br><span class="line">	)</span><br><span class="line">	slice = strings.FieldsFunc(value, func(r rune) bool &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">	&#125;)</span><br><span class="line">	mp = make(map[string]string)</span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">str</span> := range slice &#123;</span><br><span class="line">		<span class="keyword">if</span> _, <span class="attr">ok</span> := mp[str]; !ok &#123;</span><br><span class="line">			mp[str] = <span class="built_in">document</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = make([]mapreduce.KeyValue, <span class="number">0</span>, len(mp))</span><br><span class="line">	<span class="keyword">for</span> k, <span class="attr">v</span> := range mp &#123;</span><br><span class="line">		ret  = append(ret, mapreduce.KeyValue&#123;<span class="attr">Key</span>: k, <span class="attr">Value</span>: v&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by Map, with a</span></span><br><span class="line"><span class="comment">// list of that key&#x27;s string value (merged across all inputs). The return value</span></span><br><span class="line"><span class="comment">// should be a single output value for that key.</span></span><br><span class="line">func reduceF(key string, values []string) string &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	sort.Strings(values)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v %v&quot;</span>, len(values), strings.Join(values, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag"># 分布式系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/02/notify-%E4%B8%8EnotifyAll/" rel="prev" title="notify()与notifyAll()">
      <i class="fa fa-chevron-left"></i> notify()与notifyAll()
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-I"><span class="nav-number">1.</span> <span class="nav-text">Part I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-II"><span class="nav-number">2.</span> <span class="nav-text">Part II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-III-amp-IV"><span class="nav-number">3.</span> <span class="nav-text">Part III&amp;IV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-V"><span class="nav-number">4.</span> <span class="nav-text">Part V</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Roger Meng</p>
  <div class="site-description" itemprop="description">给我点学习的动力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
