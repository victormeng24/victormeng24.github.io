<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="给我点学习的动力">
<meta property="og:type" content="website">
<meta property="og:title" content="怒吃树的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="怒吃树的博客">
<meta property="og:description" content="给我点学习的动力">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Roger Meng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>怒吃树的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">怒吃树的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/06/MIT-6-824-2018-LAB1-MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/MIT-6-824-2018-LAB1-MapReduce/" class="post-title-link" itemprop="url">MIT-6.824-2018-LAB1-MapReduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-06 12:30:16" itemprop="dateCreated datePublished" datetime="2020-06-06T12:30:16+08:00">2020-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>6.824，MIT的神课之一，转Golang的机会正好作为一次练习。目前Lab1已经刷完，感觉还是很有收获，尤其是踩了些Go的坑，<a target="_blank" rel="noopener" href="https://github.com/victormeng24/6.824" title="Github地址">Github地址</a>。</p>
<h1 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h1><blockquote>
<p>The Map/Reduce implementation you are given is missing some pieces. Before you can write your first Map/Reduce function pair, you will need to fix the sequential implementation. In particular, the code we give you is missing two crucial pieces: the function that divides up the output of a map task, and the function that gathers all the inputs for a reduce task. These tasks are carried out by the doMap() function in common_map.go, and the doReduce() function in common_reduce.go respectively. The comments in those files should point you in the right direction.</p>
<p>To help you determine if you have correctly implemented doMap() and doReduce(), we have provided you with a Go test suite that checks the correctness of your implementation. These tests are implemented in the file test_test.go. To run the tests for the sequential implementation that you have now fixed, run:_</p>
</blockquote>
<p>PartI是对Map/Reduce function的一个简单实现（不是具体的Mr逻辑，而是对于文件操作的骨架实现），主要是帮助你熟悉Golang的一些对于文件IO的语法，整体没有太大难度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">func doMap(</span><br><span class="line">	jobName string, <span class="comment">// the name of the MapReduce job</span></span><br><span class="line">	mapTask int,    <span class="comment">// which map task this is</span></span><br><span class="line">	inFile string,</span><br><span class="line">	nReduce int, <span class="comment">// the number of reduce task that will be run (&quot;R&quot; in the paper)</span></span><br><span class="line">	mapF func(filename string, contents string) []KeyValue,</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// doMap manages one map task: it should read one of the input files</span></span><br><span class="line">	<span class="comment">// (inFile), call the user-defined map function (mapF) for that file&#x27;s</span></span><br><span class="line">	<span class="comment">// contents, and partition mapF&#x27;s output into nReduce intermediate files.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// There is one intermediate file per reduce task. The file name</span></span><br><span class="line">	<span class="comment">// includes both the map task number and the reduce task number. Use</span></span><br><span class="line">	<span class="comment">// the filename generated by reduceName(jobName, mapTask, r)</span></span><br><span class="line">	<span class="comment">// as the intermediate file for reduce task r. Call ihash() (see</span></span><br><span class="line">	<span class="comment">// below) on each key, mod nReduce, to pick r for a key/value pair.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// mapF() is the map function provided by the application. The first</span></span><br><span class="line">	<span class="comment">// argument should be the input file name, though the map function</span></span><br><span class="line">	<span class="comment">// typically ignores it. The second argument should be the entire</span></span><br><span class="line">	<span class="comment">// input file contents. mapF() returns a slice containing the</span></span><br><span class="line">	<span class="comment">// key/value pairs for reduce; see common.go for the definition of</span></span><br><span class="line">	<span class="comment">// KeyValue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Look at Go&#x27;s ioutil and os packages for functions to read</span></span><br><span class="line">	<span class="comment">// and write files.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Coming up with a scheme for how to format the key/value pairs on</span></span><br><span class="line">	<span class="comment">// disk can be tricky, especially when taking into account that both</span></span><br><span class="line">	<span class="comment">// keys and values could contain newlines, quotes, and any other</span></span><br><span class="line">	<span class="comment">// character you can think of.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// One format often used for serializing data to a byte stream that the</span></span><br><span class="line">	<span class="comment">// other end can correctly reconstruct is JSON. You are not required to</span></span><br><span class="line">	<span class="comment">// use JSON, but as the output of the reduce tasks *must* be JSON,</span></span><br><span class="line">	<span class="comment">// familiarizing yourself with it here may prove useful. You can write</span></span><br><span class="line">	<span class="comment">// out a data structure as a JSON string to a file using the commented</span></span><br><span class="line">	<span class="comment">// code below. The corresponding decoding functions can be found in</span></span><br><span class="line">	<span class="comment">// common_reduce.go.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   enc := json.NewEncoder(file)</span></span><br><span class="line">	<span class="comment">//   for _, kv := ... &#123;</span></span><br><span class="line">	<span class="comment">//     err := enc.Encode(&amp;kv)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Remember to close the file after you have written all the values!</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part I).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	content, <span class="attr">err</span> := ioutil.ReadFile(inFile)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	keyValue := mapF(inFile, string(content))</span><br><span class="line">	mapper := make([][]KeyValue, nReduce)</span><br><span class="line">	<span class="comment">// determine to which reducer</span></span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">v</span> := range keyValue &#123;</span><br><span class="line">		idx := ihash(v.Key) % nReduce</span><br><span class="line">		mapper[idx] = append(mapper[idx], v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write to target File</span></span><br><span class="line">	<span class="keyword">for</span> index, <span class="attr">v</span> := range mapper &#123;</span><br><span class="line">		targetFileName := reduceName(jobName, mapTask, index)</span><br><span class="line">		fileNameToChoose, <span class="attr">err</span> := os.Create(targetFileName)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		ret, <span class="attr">err</span> := json.Marshal(v)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fileNameToChoose.Write(ret)</span><br><span class="line">		fileNameToChoose.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func doReduce(</span><br><span class="line">	jobName string, <span class="comment">// the name of the whole MapReduce job</span></span><br><span class="line">	reduceTask int, <span class="comment">// which reduce task this is</span></span><br><span class="line">	outFile string, <span class="comment">// write the output here</span></span><br><span class="line">	nMap int,       <span class="comment">// the number of map tasks that were run (&quot;M&quot; in the paper)</span></span><br><span class="line">	reduceF func(key string, values []string) string,</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// doReduce manages one reduce task: it should read the intermediate</span></span><br><span class="line">	<span class="comment">// files for the task, sort the intermediate key/value pairs by key,</span></span><br><span class="line">	<span class="comment">// call the user-defined reduce function (reduceF) for each key, and</span></span><br><span class="line">	<span class="comment">// write reduceF&#x27;s output to disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You&#x27;ll need to read one intermediate file from each map task;</span></span><br><span class="line">	<span class="comment">// reduceName(jobName, m, reduceTask) yields the file</span></span><br><span class="line">	<span class="comment">// name from map task m.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your doMap() encoded the key/value pairs in the intermediate</span></span><br><span class="line">	<span class="comment">// files, so you will need to decode them. If you used JSON, you can</span></span><br><span class="line">	<span class="comment">// read and decode by creating a decoder and repeatedly calling</span></span><br><span class="line">	<span class="comment">// .Decode(&amp;kv) on it until it returns an error.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You may find the first example in the golang sort package</span></span><br><span class="line">	<span class="comment">// documentation useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// reduceF() is the application&#x27;s reduce function. You should</span></span><br><span class="line">	<span class="comment">// call it once per distinct key, with a slice of all the values</span></span><br><span class="line">	<span class="comment">// for that key. reduceF() returns the reduced value for that key.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You should write the reduce output as JSON encoded KeyValue</span></span><br><span class="line">	<span class="comment">// objects to the file named outFile. We require you to use JSON</span></span><br><span class="line">	<span class="comment">// because that is what the merger than combines the output</span></span><br><span class="line">	<span class="comment">// from all the reduce tasks expects. There is nothing special about</span></span><br><span class="line">	<span class="comment">// JSON -- it is just the marshalling format we chose to use. Your</span></span><br><span class="line">	<span class="comment">// output code will look something like this:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// enc := json.NewEncoder(file)</span></span><br><span class="line">	<span class="comment">// for key := ... &#123;</span></span><br><span class="line">	<span class="comment">// 	enc.Encode(KeyValue&#123;key, reduceF(...)&#125;)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// file.Close()</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part I).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	keyV := make(map[string][]string)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">		mapFileName := reduceName(jobName, i, reduceTask)</span><br><span class="line">		input, <span class="attr">err</span> := ioutil.ReadFile(mapFileName)</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> tmpKeyv []KeyValue</span><br><span class="line">		json.Unmarshal(input, &amp;tmpKeyv)</span><br><span class="line">		<span class="keyword">for</span> _, <span class="attr">v</span> := range tmpKeyv &#123;</span><br><span class="line">			keyV[v.Key] = append(keyV[v.Key], v.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	outputFile, <span class="attr">err</span> := os.Create(outFile)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enc := json.NewEncoder(outputFile)</span><br><span class="line">	<span class="keyword">for</span> key, <span class="attr">value</span> := range keyV &#123;</span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(KeyValue&#123;key, reduceF(key, value)&#125;); err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := outputFile.Close(); err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h1><blockquote>
<p>Now you will implement word count — a simple Map/Reduce example. Look in main/wc.go; you’ll find empty mapF() and reduceF() functions. Your job is to insert code so that wc.go reports the number of occurrences of each word in its input. A word is any contiguous sequence of letters, as determined by unicode.IsLetter.</p>
</blockquote>
<p>实现一个WordCount的mr function，其实也很简单，主要是熟悉一下Golang的api-&gt;如何将一篇文章拆分成string的slice？strings. FieldsFunc(s string, f func(rune) bool)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func mapF(filename string, contents string) []mapreduce.KeyValue &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	strArr := strings.FieldsFunc(contents, func(r rune) bool &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">	&#125;)</span><br><span class="line">	ret := make([]mapreduce.KeyValue, <span class="number">0</span>, len(strArr))</span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">str</span> := range strArr &#123;</span><br><span class="line">		kv := mapreduce.KeyValue&#123;<span class="attr">Key</span>: str, <span class="attr">Value</span>: <span class="string">&quot;1&quot;</span>&#125;</span><br><span class="line">		ret = append(ret, kv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">func reduceF(key string, values []string) string &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, len(values))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Part-III-amp-IV"><a href="#Part-III-amp-IV" class="headerlink" title="Part III&amp;IV"></a>Part III&amp;IV</h1><blockquote>
<p>Your current implementation runs the map and reduce tasks one at a time. One of Map/Reduce’s biggest selling points is that it can automatically parallelize ordinary sequential code without any extra work by the developer. In this part of the lab, you will complete a version of MapReduce that splits the work over a set of worker threads that run in parallel on multiple cores. While not distributed across multiple machines as in real Map/Reduce deployments, your implementation will use RPC to simulate distributed computation.<br>In this part you will make the master handle failed workers. MapReduce makes this relatively easy because workers don’t have persistent state. If a worker fails while handling an RPC from the master, the master’s call() will eventually return false due to a timeout. In that situation, the master should re-assign the task given to the failed worker to another worker.</p>
</blockquote>
<blockquote>
<p>An RPC failure doesn’t necessarily mean that the worker didn’t execute the task; the worker may have executed it but the reply was lost, or the worker may still be executing but the master’s RPC timed out. Thus, it may happen that two workers receive the same task, compute it, and generate output. Two invocations of a map or reduce function are required to generate the same output for a given input (i.e. the map and reduce functions are “functional”), so there won’t be inconsistencies if subsequent processing sometimes reads one output and sometimes the other. In addition, the MapReduce framework ensures that map and reduce function output appears atomically: the output file will either not exist, or will contain the entire output of a single execution of the map or reduce function (the lab code doesn’t actually implement this, but instead only fails workers at the end of a task, so there aren’t concurrent executions of a task).</p>
</blockquote>
<p>Part III和Part IV，如果你对Goroutine和Channel不是很了解的话，实现起来就有难度了。PartIII是实现一个Mr的分布式调度器schedule()，RPC通信的框架和Worker的DoTask课程都为我们实现了，我们需要考虑的就是Master节点如何调度Worker完成具体的作业，以及（PartIV）当Worker Failure了之后如何实现高可用（将分配给该Worker的任务重新分配给另一个Worker）。实现要求我们只改动schedule.go中的schedule() function：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks int</span><br><span class="line">	<span class="keyword">var</span> n_other int <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = len(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = len(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;</span>, ntasks, phase, n_other)</span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		args := &amp;DoTaskArgs&#123;</span><br><span class="line">			JobName:       jobName,</span><br><span class="line">			File:          mapFiles[i],</span><br><span class="line">			Phase:         phase,</span><br><span class="line">			TaskNumber:    i,</span><br><span class="line">			NumOtherPhase: n_other&#125;</span><br><span class="line">		go func(ch chan string, args *DoTaskArgs) &#123;</span><br><span class="line">			worker := <span class="xml"><span class="tag">&lt;<span class="name">-registerChan</span></span></span></span><br><span class="line"><span class="xml">			for !call(worker, &quot;Worker.DoTask&quot;, args, nil) &#123;</span></span><br><span class="line">				worker = &lt;-registerChan</span><br><span class="line">			&#125;</span><br><span class="line">			// start a goroutine to avoid block</span><br><span class="line">			go func() &#123;</span><br><span class="line">				registerChan &lt;- worker</span><br><span class="line">			&#125;()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(registerChan, args)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(&quot;Schedule: %v done\n&quot;, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是通过一个Channel对可用的Worker进行控制，调度任务时首先获取Worker，任务执行完毕后释放Worker。当Worker任务执行失败时重新选择一个可用的Worker。<br>需要注意的是任务执行完毕后为什么要启动另一个goroutine来释放worker呢？因为registerChan &lt;- worker是一个阻塞操作，当channel中有worker的时候会阻塞在这里导致主函数无法继续执行。</p>
<h1 id="Part-V"><a href="#Part-V" class="headerlink" title="Part V"></a>Part V</h1><blockquote>
<p>For this optional no-credit exercise, you will build Map and Reduce functions for generating an inverted index.</p>
<p>Inverted indices are widely used in computer science, and are particularly useful in document searching. Broadly speaking, an inverted index is a map from interesting facts about the underlying data, to the original location of that data. For example, in the context of search, it might be a map from keywords to documents that contain those words.</p>
<p>We have created a second binary in main/ii.go that is very similar to the wc.go you built earlier. You should modify mapF and reduceF in main/ii.go so that they together produce an inverted index. Running ii.go should output a list of tuples, one per line, in the following format:</p>
</blockquote>
<p>可选题，写的Challenge其实我觉得比3、4简单很多。。实现一个倒排索引，统计单词出现在几篇文章中以及这些文章的list，和PartII的逻辑基本没什么区别，加一个map实现去重即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The mapping function is called once for each piece of the input.</span></span><br><span class="line"><span class="comment">// In this framework, the key is the name of the file that is being processed,</span></span><br><span class="line"><span class="comment">// and the value is the file&#x27;s contents. The return value should be a slice of</span></span><br><span class="line"><span class="comment">// key/value pairs, each represented by a mapreduce.KeyValue.</span></span><br><span class="line">func mapF(<span class="built_in">document</span> string, value string) (res []mapreduce.KeyValue) &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		slice []string</span><br><span class="line">		mp    map[string]string</span><br><span class="line">		ret   []mapreduce.KeyValue</span><br><span class="line">	)</span><br><span class="line">	slice = strings.FieldsFunc(value, func(r rune) bool &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">	&#125;)</span><br><span class="line">	mp = make(map[string]string)</span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">str</span> := range slice &#123;</span><br><span class="line">		<span class="keyword">if</span> _, <span class="attr">ok</span> := mp[str]; !ok &#123;</span><br><span class="line">			mp[str] = <span class="built_in">document</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = make([]mapreduce.KeyValue, <span class="number">0</span>, len(mp))</span><br><span class="line">	<span class="keyword">for</span> k, <span class="attr">v</span> := range mp &#123;</span><br><span class="line">		ret  = append(ret, mapreduce.KeyValue&#123;<span class="attr">Key</span>: k, <span class="attr">Value</span>: v&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by Map, with a</span></span><br><span class="line"><span class="comment">// list of that key&#x27;s string value (merged across all inputs). The return value</span></span><br><span class="line"><span class="comment">// should be a single output value for that key.</span></span><br><span class="line">func reduceF(key string, values []string) string &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	sort.Strings(values)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v %v&quot;</span>, len(values), strings.Join(values, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/02/notify-%E4%B8%8EnotifyAll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/notify-%E4%B8%8EnotifyAll/" class="post-title-link" itemprop="url">notify()与notifyAll()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-02 14:54:58" itemprop="dateCreated datePublished" datetime="2020-06-02T14:54:58+08:00">2020-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>谈notify()与notifyAll()之前，需要明确锁池和等待池两个概念：<br>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。<br>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</p>
<ul>
<li>当一个线程调用wait()时，代表让出持有的对象锁，同时自身进入等待池，处于等待池的线程不会去竞争对象锁</li>
<li>当一个线程调用notify()或者notifyAll()时，前者会从等待池中随机选择一个线程进入锁池来竞争对象锁，而后者会将等待池中的全部线程放入锁池中，这就是notify()和notifyAll()的区别</li>
<li>从notify()和notifyAll()的作用来看，理想状态下，竞争锁的线程应当具有相同的职能，否则会造成无用的开销甚至死锁（一个典型的死锁场景会在后面介绍）。如果需要对不同角色的线程进行类似wait&amp;notify的控制，可以使用Lock&amp;Condition来实现<br>关于nofify()产生死锁的场景，可以想象一个典型的多生产者消费者的场景：<br>生产者、消费者数量都为2，缓冲区为1，当按照下列并发顺序执行的时候出现死锁：</li>
</ul>
<p>1.消费者1获得锁，发现缓冲区为0，wait（wait自动释放锁）（等待池：消费者1 锁池：消费者2、生产者1、生产者2）<br>2.消费者2获得锁，发现缓冲区为0，wait（wait自动释放锁）（等待池：消费者1、消费者2  锁池：生产者1、生产者2）<br>3.生产者1获得锁，发现缓冲区为0可以生产，生产以后放在缓冲区，notify，现在缓冲区为1（等待池：消费者1、消费者2  锁池：生产者2）<br>4.第3步notify唤醒了消费者1，但是消费者1没有抢到锁，锁被生产者2拿到了；（等待池：消费者2  锁池：消费者1）<br>5.生产者2发现缓冲区为1（因为只是唤醒了消费者1，但是消费者1没有抢到锁，没法消费），wait（wait自动释放锁）；（等待池：消费者2 、生产者2 锁池：消费者1）<br>6.消费者1获得了锁，消费并且notify（此时生产者2和消费者2都处于wait状态），缓冲区为0；（等待池：消费者2 、生产者2 锁池：）<br>7.notify唤醒了消费者2，消费者2醒来后拿到锁发现缓冲区为0，接着wait，与此同时，生产者2也在wait，死锁产生。<br>造成这种情况的原因是：</p>
<ol>
<li>被notify()的线程不能保证持有锁</li>
<li>notify()可能唤醒同一角色的线程</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/01/Golang%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Golang%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">Golang的性能测试与性能分析工具（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-01 15:56:23" itemprop="dateCreated datePublished" datetime="2020-06-01T15:56:23+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对pprof做个简单总结和演示</p>
<ol>
<li>可通过HTTP请求的方式，导入”net/http/pprof”，访问<a href="http://ip:port/debug/pprof/">http://ip:port/debug/pprof/</a></li>
<li>命令行方式，以cpu性能测试为例 go tool pprof <a href="http://ip:port/debug/pprof/profile?seconds=10，10s为单位进行采样。">http://ip:port/debug/pprof/profile?seconds=10，10s为单位进行采样。</a></li>
<li>可以通过代码嵌入的方式对代码块进行详细分析。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fi, <span class="attr">err</span> := os.Create(<span class="string">&quot;cpu.prof&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.StartCPUProfile(fi)</span><br><span class="line"><span class="comment">// your code </span></span><br><span class="line">pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure></li>
<li>分析.prof文件的命令 go tool pprof prof filename.prof</li>
<li>go test也支持profile输出性能分析文件 go test -bench=flag -cpuprofile=file.prof</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="HTTP请求采样"><a href="#HTTP请求采样" class="headerlink" title="HTTP请求采样"></a>HTTP请求采样</h2><p>用简单的make slice方式来进行一下性能分析，代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/julienschmidt/httprouter&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Index(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprint(w, <span class="string">&quot;Welcome!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func LoopSlice(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	<span class="keyword">var</span> fbs []int</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">		fbs = MakeSlice(<span class="number">100</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	w.Write([]byte(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, fbs)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MakeSlice(n int) []int &#123;</span><br><span class="line">	<span class="keyword">var</span> ret []int</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		ret = append(ret, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, Index)</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/loop&quot;</span>, LoopSlice)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动Server后，我们运行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile\?seconds\=10</span></span><br></pre></td></tr></table></figure>
<p>进行采样，简单对localhost:8080/loop进行几次模拟请求，得到采样结果：<br><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/pprof_cpu_sample.png"><br>可以看到cpu时间集中在append上（slice扩容）</p>
<h2 id="Benchmark输出输出prof结果"><a href="#Benchmark输出输出prof结果" class="headerlink" title="Benchmark输出输出prof结果"></a>Benchmark输出输出prof结果</h2><p>我们换一种方式，采用benchmark输出prof来进行性能分析，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line">func BenchmarkRequest(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">var</span> _ []int</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		_ = MakeSlice(<span class="number">100000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MakeSlices(n int) []int &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []int</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		slice = append(slice, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 go test -bench=. -memprofile=mem.prof 将结果输出到men.prof文件中，用 go tool pprof mem.prof 分析 mem.prof<br>￼<img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/pprof_mem_sample.png"><br>可以看到append对于内存的消耗</p>
<h2 id="一个有趣的问题"><a href="#一个有趣的问题" class="headerlink" title="一个有趣的问题"></a>一个有趣的问题</h2><p>我们对Go中的RWMutex（读写锁）的读锁进行性能测试，代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	m = make(map[string]string)</span><br><span class="line">	m[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">	m[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func LockFreeAccess() &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(NumberReaders)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumberReaders; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; ReadTimes; j++ &#123;</span><br><span class="line">				_, <span class="attr">ok</span> := m[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func LockAccess() &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(NumberReaders)</span><br><span class="line">	rwLock := sync.RWMutex&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumberReaders; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; ReadTimes; j++ &#123;</span><br><span class="line">				rwLock.RLock()</span><br><span class="line">				_, <span class="attr">ok</span> := m[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				rwLock.RUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkLockFree(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		LockFreeAccess()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkLock(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		LockAccess()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先进行Benchmark，得到的结果<br><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/rwmutex_bench.png"><br>即使读锁之前并不存在互斥，加了读锁的多协程并发性能并不好，将bench的cpu测试输出到cpu.prof，分析结果如下<br><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/rwmutex_cpuprof.png"><br>RWMutex的Rlock和Runlock占用的cpu时间极长。因此，读锁的不互斥并不代表着加了读锁之后的并发读性能会不受影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/01/Golang%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Golang%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">Golang的性能测试与性能分析工具（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-01 13:24:44" itemprop="dateCreated datePublished" datetime="2020-06-01T13:24:44+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStrAdd(b *testing.B)</span><br></pre></td></tr></table></figure>
<p>被称为golang的基准测试，定义了以Benchmark开头的function后，通过”go test -bench FLAG”命令<br>多个基准测试将按照顺序进行执行。<br>testing.B中封装了Benchmark中常用的方法调用。</p>
<h2 id="ResetTimer"><a href="#ResetTimer" class="headerlink" title="ResetTimer"></a>ResetTimer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResetTimer zeroes the elapsed benchmark time and memory allocation counters</span></span><br><span class="line"><span class="comment">// and deletes user-reported metrics.</span></span><br><span class="line"><span class="comment">// It does not affect whether the timer is running.</span></span><br><span class="line">func (b *B) ResetTimer()</span><br></pre></td></tr></table></figure>
<h2 id="StopTimer"><a href="#StopTimer" class="headerlink" title="StopTimer"></a>StopTimer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StopTimer stops timing a test. This can be used to pause the timer</span></span><br><span class="line"><span class="comment">// while performing complex initialization that you don&#x27;t</span></span><br><span class="line"><span class="comment">// want to measure.</span></span><br><span class="line">func (b *B) StopTimer()</span><br></pre></td></tr></table></figure>
<h2 id="ReportAllocs"><a href="#ReportAllocs" class="headerlink" title="ReportAllocs"></a>ReportAllocs</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReportAllocs enables malloc statistics for this benchmark.</span></span><br><span class="line"><span class="comment">// It is equivalent to setting -test.benchmem, but it only affects the</span></span><br><span class="line"><span class="comment">// benchmark function that calls ReportAllocs.</span></span><br><span class="line">func (b *B) ReportAllocs()</span><br></pre></td></tr></table></figure>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>以字符串拼接为例，我们对比StringConcat、BytesBuffer和StringBuilder字符串拼接的性能，代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func BenchmarkStrAdd(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b.N; j++ &#123;</span><br><span class="line">		ret := <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			ret += strconv.Itoa(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.ReportAllocs()</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkByteBuffer(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b.N; j++ &#123;</span><br><span class="line">		ret := bytes.Buffer&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			ret.WriteString(strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">		_ = ret.String()</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder(b *testing.B) &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; b.N; j++ &#123;</span><br><span class="line">		ret := strings.Builder&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			ret.WriteString(strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">		_ = ret.String()</span><br><span class="line">	&#125;</span><br><span class="line">	b.StopTimer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码 go test -bench . 结果如下<br><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/go_benchmark.png"><br>可以看到StringBuilder的性能略好于BytesBuffer，两者远好于StringConcat，我们还可以通过-benchmem查看内存的Benchmark<br><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/go_benchmark_mem.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/03/04/Leetcode-Go-26&27-RemoveDuplicates&Elements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/04/Leetcode-Go-26&27-RemoveDuplicates&Elements/" class="post-title-link" itemprop="url">Leetcode-Go-26&27-RemoveDuplicates&Elements</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-04 14:41:22" itemprop="dateCreated datePublished" datetime="2020-03-04T14:41:22+08:00">2020-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="26-Remove-Duplicates-in-Sorted-Array"><a href="#26-Remove-Duplicates-in-Sorted-Array" class="headerlink" title="26-Remove Duplicates in Sorted Array"></a>26-Remove Duplicates in Sorted Array</h1><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<p>给定数组 nums = <a href="">1,1,2</a>, </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = <a href="">0,0,1,1,1,2,2,3,3,4</a>,</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>思路：快慢指针，慢指针用于保存新数组的长度，快指针遍历整个数组，当快慢指针相等时快指针跳过，表示遇到重复元素，不等时，交换快指针索引与慢指针索引+1的值，最后的前i+1项即为去重后的数组元素。<br>自己写了个实现，又看了下解题圈子里的实现，感觉自己的代码还是不够优雅，需要继续努力。<br>自己代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">	<span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	i, <span class="attr">j</span> := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i&lt;len(nums) <span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j &lt; len(nums) &amp;&amp; nums[i] == nums[j] &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> j == len(nums) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		nums[i+<span class="number">1</span>] = nums[j]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func removeDuplicates(nums []int) int &#123;</span><br><span class="line">	<span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	i, <span class="attr">j</span> := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; j &lt; len(nums); j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] != nums[j] &#123;</span><br><span class="line">			i++</span><br><span class="line">			nums[i] = nums[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过有趣的是上面我写的代码平均执行时间是8ms左右，下面这个代码要18ms左右，不太了解编译器对上面两种代码是如何进行优化的，后面有机会可以深入了解下。</p>
<h1 id="27-Remove-Elements"><a href="#27-Remove-Elements" class="headerlink" title="27-Remove Elements"></a>27-Remove Elements</h1><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1:</p>
<p>给定 nums = <a href="">3,2,2,3</a>, val = 3,</p>
<p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = <a href="">0,1,2,2,3,0,4,2</a>, val = 2,</p>
<p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p>注意这五个元素可为任意顺序。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>类似地，第27题基本也是相同的思路，只不过快指针指向指向数组尾部，当头指针发现元素等于目标值时，将其与尾指针指向元素交换，代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func removeElement(nums []int, val int) int &#123;</span><br><span class="line">	<span class="keyword">if</span> len(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	i, <span class="attr">j</span> := <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i &lt;= j &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">			nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">			j--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/26/Leetcode-Go-Reverse-Integer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/Leetcode-Go-Reverse-Integer/" class="post-title-link" itemprop="url">Leetcode-Go-Reverse Integer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 13:40:02" itemprop="dateCreated datePublished" datetime="2020-02-26T13:40:02+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<p>输入: 123<br>输出: 321<br> 示例 2:</p>
<p>输入: -123<br>输出: -321<br>示例 3:</p>
<p>输入: 120<br>输出: 21<br>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 <a href="">−231,  231 − 1</a>。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>题目很简单，唯一需要注意的地方是边界值问题，int类型的数据在反转时可能溢出，借本道题了解下Go的testing包，上代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func reverse(x int) int &#123;</span><br><span class="line">	y := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">		y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">		x = x / <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> y &gt; <span class="number">1</span> &lt;&lt; <span class="number">31</span> <span class="number">-1</span>  || y &lt; -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type question7 struct &#123;</span><br><span class="line">	para7</span><br><span class="line">	ans7</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// para 是参数</span></span><br><span class="line"><span class="comment">// one 代表第一个参数</span></span><br><span class="line">type para7 struct &#123;</span><br><span class="line">	one int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ans 是答案</span></span><br><span class="line"><span class="comment">// one 代表第一个答案</span></span><br><span class="line">type ans7 struct &#123;</span><br><span class="line">	one int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Test_Problem7(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">	qs := []question7&#123;</span><br><span class="line"></span><br><span class="line">		question7&#123;</span><br><span class="line">			para7&#123;<span class="number">321</span>&#125;,</span><br><span class="line">			ans7&#123;<span class="number">123</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		question7&#123;</span><br><span class="line">			para7&#123;<span class="number">-123</span>&#125;,</span><br><span class="line">			ans7&#123;<span class="number">-321</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		question7&#123;</span><br><span class="line">			para7&#123;<span class="number">120</span>&#125;,</span><br><span class="line">			ans7&#123;<span class="number">21</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		question7&#123;</span><br><span class="line">			para7&#123;<span class="number">1534236469</span>&#125;,</span><br><span class="line">			ans7&#123;<span class="number">0</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;------------------------Leetcode Problem 7------------------------\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, <span class="attr">q</span> := range qs &#123;</span><br><span class="line">		ans, <span class="attr">p</span> := q.ans7, q.para7</span><br><span class="line">		fmt.Printf(<span class="string">&quot;【input】:%v    【output】:%v    [expectoutput]:%v\n&quot;</span>, p.one, reverse(p.one), ans.one)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n\n\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>testing参考的git上这个项目：<a target="_blank" rel="noopener" href="https://github.com/halfrost/LeetCode-Go">https://github.com/halfrost/LeetCode-Go</a>，对Go和力扣有兴趣的也可以看这个项目，带解析和测试用例。<br>目前对Go的测试有些简单了解：</p>
<ul>
<li>文件名以<em>test.go结尾</em></li>
<li>引入testing包，是Go的基础测试工具</li>
<li>运行go test，编译执行当前目录下所有test.go测试文件</li>
<li>函数名以Test开头，如果是benchmark以Benchmark开头</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/21/%E7%94%A8Golang%E5%88%B7%E4%B8%80%E9%81%8DLeetCode-Two-Sum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/21/%E7%94%A8Golang%E5%88%B7%E4%B8%80%E9%81%8DLeetCode-Two-Sum/" class="post-title-link" itemprop="url">用Golang刷一遍LeetCode-Two Sum</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-21 17:36:35" itemprop="dateCreated datePublished" datetime="2020-01-21T17:36:35+08:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>心血来潮想学一下Go，从最基础的数据结构算法开始学起吧，之前Java刷LeetCode也刷了不少遍，想用Golang把这些题重新写一遍。第一题来看最经典的Two Sum。<br>PS：一年多不见，LeetCode已经变成了力扣，有了中文官网，可见中国的程序员们对这玩意儿也是刚需了。。</p>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = <a href="">2, 7, 11, 15</a>, target = 9</p>
<p>因为 nums<a href="">0</a> + nums<a href="">1</a> = 2 + 7 = 9<br>所以返回 <a href="">0, 1</a></p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>暴力遍历时间复杂度O(n^2)，想要O(n)的解需要一个Map来存数据的value和index，题很简单，借机了解Go的一些语法，上代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func twoSum(nums []int, target int) []int &#123;</span><br><span class="line">	m := make(map[int]int)</span><br><span class="line">	<span class="keyword">for</span> i, <span class="attr">v</span> := range nums &#123;</span><br><span class="line">		<span class="keyword">if</span> k, <span class="attr">ok</span> := m[target - v]; ok &#123;</span><br><span class="line">			<span class="keyword">return</span> []int&#123;k, i&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		m[v] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Go第一个比较惊艳的是这个ok的断言方式，感觉非常优雅，用在Map里面做key值非空的判断可以让代码非常简洁。<br>另外用range遍历数组会产生数组的index和value两个值，这个用起来感觉也蛮方便。<br>持续学习中。。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/15/Fisher%E2%80%93Yates%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/Fisher%E2%80%93Yates%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Fisher–Yates洗牌算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 10:36:23" itemprop="dateCreated datePublished" datetime="2020-01-15T10:36:23+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>洗牌算法这个问题可以看作是一个概率问题，不妨先看这样一个简单的问题：<br><strong>1-100这100个数字落在一个数组里，如何随机从中取出一个数呢？</strong><br>直接使用Random函数返回一个数组下标，取到对应的值即可。<br>那么将这个问题改一改，<strong>如果是随机取出50个数呢</strong>？注意我们取数一定是不能重复的，如果按照Random的方法循环50次，就会带来一个问题：随着Random的次数越来越多，取到相同数字的概率会越来越大，每次取到相同的数就要丢掉再次Random直到取到不重复的数为止。<br>这种暴力算法随着取数的规模扩大，显然效率会指数性的下降。是否有一种算法能够确保每个数被取到的概率是相等的且比较高效呢？Fisher–Yates Shuffle</p>
<h1 id="Fisher-Yates"><a href="#Fisher-Yates" class="headerlink" title="Fisher-Yates"></a>Fisher-Yates</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=suit.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        random1 = Random.next(<span class="number">1</span>,i);</span><br><span class="line">        exchange(suit[random1],suit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<p>这个算法不但效率很高而且非常优雅，整个逻辑非常简单：<br>取0～i-1索引的一个随机数random1，交换suit[i]与suit[random1]的值，循环此步骤生成的序列就是一个随机序列。<br>Fisher–Yates算法在原理上保证了不会出现浪费次数，重复选择的情况，导致样本空间一直保持n！，没有坍缩；代码精简优雅，体现了算法和数学之美。<br>它的随机性也很好证明，一个元素k被放入第i个位置的概率P = 前i-1个位置选择元素时没有选中k的概率 * 第i个位置选中m的概率*<br><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/fisher_yates.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/13/Java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/Java%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Java的四种引用类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 16:24:51" itemprop="dateCreated datePublished" datetime="2020-01-13T16:24:51+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>JVM内存是不需要程序员进行管理的，JVM本身会在适当的时候进行GC。为了辅助程序员控制Object的生命周期，Java提供了四种引用类型，按引用强度由高到低为：StrongReference(强引用）、SoftReference(软引用）、WeakReference(弱引用）、PhantomReference(虚引用)</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Reference也是一个一个对象，下面是它的部分源码，我对一些域和方法添加了中文注释：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//持有的引用对象</span></span><br><span class="line">    private T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line">    <span class="comment">//引用队列，在下面的构造器中传入</span></span><br><span class="line">    volatile ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When active:   NULL</span></span><br><span class="line"><span class="comment">     *     pending:   this</span></span><br><span class="line"><span class="comment">     *    Enqueued:   next reference in queue (or this if last)</span></span><br><span class="line"><span class="comment">     *    Inactive:   this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//指针指向队列下一个引用</span></span><br><span class="line">    @SuppressWarnings(<span class="string">&quot;rawtypes&quot;</span>)</span><br><span class="line">    volatile Reference next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When active:   next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">     *     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">     *   otherwise:   NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//jvm维护的discovered reference list，指向这个list的下一个元素</span></span><br><span class="line">    transient private Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Object used to synchronize with the garbage collector.  The collector</span></span><br><span class="line"><span class="comment">     * must acquire this lock at the beginning of each collection cycle.  It is</span></span><br><span class="line"><span class="comment">     * therefore critical that any code holding this lock complete as quickly</span></span><br><span class="line"><span class="comment">     * as possible, allocate no new objects, and avoid calling user code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> private <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;</span><br><span class="line">    private <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of References waiting to be enqueued.  The collector adds</span></span><br><span class="line"><span class="comment">     * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment">     * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment">     * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//等待加入queue的reference对象，ReferenceHandler会不断将pending对象加入到队列中。</span></span><br><span class="line">    private <span class="keyword">static</span> Reference&lt;<span class="built_in">Object</span>&gt; pending = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* High-priority thread to enqueue pending References</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        private <span class="keyword">static</span> <span class="keyword">void</span> ensureClassInitialized(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(clazz.getName(), <span class="literal">true</span>, clazz.getClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (<span class="built_in">Error</span>) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// pre-load and initialize InterruptedException and Cleaner classes</span></span><br><span class="line">            <span class="comment">// so that we don&#x27;t get into trouble later in the run loop if there&#x27;s</span></span><br><span class="line">            <span class="comment">// memory shortage while loading/initializing them lazily.</span></span><br><span class="line">            ensureClassInitialized(InterruptedException.class);</span><br><span class="line">            ensureClassInitialized(Cleaner.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceHandler(ThreadGroup g, <span class="built_in">String</span> name) &#123;</span><br><span class="line">            <span class="built_in">super</span>(g, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                tryHandlePending(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Try handle pending &#123;<span class="doctag">@link </span>Reference&#125; if there is one.&lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Return &#123;<span class="doctag">@code </span>true&#125; as a hint that there might be another</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link </span>Reference&#125; pending or &#123;<span class="doctag">@code </span>false&#125; when there are no more pending</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link </span>Reference&#125;s at the moment and the program can do some other</span></span><br><span class="line"><span class="comment">     * useful work instead of looping.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>waitForNotify if &#123;<span class="doctag">@code </span>true&#125; and there was no pending</span></span><br><span class="line"><span class="comment">     *                      &#123;<span class="doctag">@link </span>Reference&#125;, wait until notified from VM</span></span><br><span class="line"><span class="comment">     *                      or interrupted; if &#123;<span class="doctag">@code </span>false&#125;, return immediately</span></span><br><span class="line"><span class="comment">     *                      when there is no pending &#123;<span class="doctag">@link </span>Reference&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;@code true&#125;</span> </span>if there was a &#123;<span class="doctag">@link </span>Reference&#125; pending and it</span></span><br><span class="line"><span class="comment">     *         was processed, or we waited for notification and either got it</span></span><br><span class="line"><span class="comment">     *         or thread was interrupted before being notified;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code </span>false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将pending的reference添加到referencequeue中，如果pending的对象是Cleaner，直接调用clean()进行回收</span></span><br><span class="line">    <span class="keyword">static</span> boolean tryHandlePending(boolean waitForNotify) &#123;</span><br><span class="line">        Reference&lt;<span class="built_in">Object</span>&gt; r;</span><br><span class="line">        Cleaner c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    <span class="comment">// &#x27;instanceof&#x27; might throw OutOfMemoryError sometimes</span></span><br><span class="line">                    <span class="comment">// so do this before un-linking &#x27;r&#x27; from the &#x27;pending&#x27; chain...</span></span><br><span class="line">                    c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// unlink &#x27;r&#x27; from &#x27;pending&#x27; chain</span></span><br><span class="line">                    pending = r.discovered;</span><br><span class="line">                    r.discovered = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                    <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                    <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// retry if waited</span></span><br><span class="line">                    <span class="keyword">return</span> waitForNotify;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">            <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">            <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">            <span class="comment">// Also prevent CPU intensive spinning in case &#x27;r instanceof Cleaner&#x27; above</span></span><br><span class="line">            <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">            <span class="comment">// retry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fast path for cleaners</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            c.clean();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue&lt;? <span class="built_in">super</span> <span class="built_in">Object</span>&gt; q = r.queue;</span><br><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">             tgn != <span class="literal">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">        <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">         * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        handler.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean tryHandlePendingReference() &#123;</span><br><span class="line">                <span class="keyword">return</span> tryHandlePending(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Referent accessor and setters -- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  If this reference object has</span></span><br><span class="line"><span class="comment">     * been cleared, either by the program or by the garbage collector, then</span></span><br><span class="line"><span class="comment">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return   </span>The object to which this reference refers, or</span></span><br><span class="line"><span class="comment">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.referent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears this reference object.  Invoking this method will not cause this</span></span><br><span class="line"><span class="comment">     * object to be enqueued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span></span><br><span class="line"><span class="comment">     * clears references it does so directly, without invoking this method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="keyword">void</span> clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.referent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Queue operations -- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tells whether or not this reference object has been enqueued, either by</span></span><br><span class="line"><span class="comment">     * the program or by the garbage collector.  If this reference object was</span></span><br><span class="line"><span class="comment">     * not registered with a queue when it was created, then this method will</span></span><br><span class="line"><span class="comment">     * always return &lt;code&gt;false&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return   </span>&lt;code&gt;true&lt;/code&gt; if and only if this reference object has</span></span><br><span class="line"><span class="comment">     *           been enqueued</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public boolean isEnqueued() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds this reference object to the queue with which it is registered,</span></span><br><span class="line"><span class="comment">     * if any.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span></span><br><span class="line"><span class="comment">     * enqueues references it does so directly, without invoking this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return   </span>&lt;code&gt;true&lt;/code&gt; if this reference object was successfully</span></span><br><span class="line"><span class="comment">     *           enqueued; &lt;code&gt;false&lt;/code&gt; if it was already enqueued or if</span></span><br><span class="line"><span class="comment">     *           it was not registered with a queue when it was created</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public boolean enqueue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.queue.enqueue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Constructors -- */</span></span><br><span class="line"></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="built_in">this</span>(referent, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.referent = referent;</span><br><span class="line">        <span class="built_in">this</span>.queue = (queue == <span class="literal">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看下具体的实现类有何不同。</p>
<h1 id="StrongReference"><a href="#StrongReference" class="headerlink" title="StrongReference"></a>StrongReference</h1><p>StrongReference不是Reference的实现类，强引用实际上是Java的默认引用形式，使用时不需要显示定义。任何通过强引用所使用的对象不管系统资源有多紧张，Java GC都不会主动回收具有强引用的对象。<br>形如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>
<p>这样的显示声明，都是为对象建立了一个强引用，这种引用类型在我们日常coding时经常使用。</p>
<h1 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SoftReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timestamp clock, updated by the garbage collector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> private long clock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timestamp updated by each invocation of the get method.  The VM may use</span></span><br><span class="line"><span class="comment">     * this field when selecting soft references to be cleared, but it is not</span></span><br><span class="line"><span class="comment">     * required to do so.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private long timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new soft reference that refers to the given object.  The new</span></span><br><span class="line"><span class="comment">     * reference is not registered with any queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>referent object the new soft reference will refer to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public SoftReference(T referent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent);</span><br><span class="line">        <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new soft reference that refers to the given object and is</span></span><br><span class="line"><span class="comment">     * registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>referent object the new soft reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public SoftReference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q) &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">        <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  If this reference object has</span></span><br><span class="line"><span class="comment">     * been cleared, either by the program or by the garbage collector, then</span></span><br><span class="line"><span class="comment">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return   </span>The object to which this reference refers, or</span></span><br><span class="line"><span class="comment">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        T o = <span class="built_in">super</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.timestamp != clock)</span><br><span class="line">            <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clock是一个静态域，如注释中所说，这个值会在gc时被更新，值为当前gc的时间，timestamp当调用get()时会被赋值成clock值。<br>这两个值具体用途是什么呢？<br>以下内容部分转自掘金：<br>作者：做个好人君<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5bdfaeace51d4520b66399f1">https://juejin.im/post/5bdfaeace51d4520b66399f1</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">ReferenceProcessor::process_discovered_reflist(</span><br><span class="line">  DiscoveredList               refs_lists[],</span><br><span class="line">  ReferencePolicy*             policy,</span><br><span class="line">  bool                         clear_referent,</span><br><span class="line">  BoolObjectClosure*           is_alive,</span><br><span class="line">  OopClosure*                  keep_alive,</span><br><span class="line">  VoidClosure*                 complete_gc,</span><br><span class="line">  AbstractRefProcTaskExecutor* task_executor)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line">      <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">        process_phase1(refs_lists[i], policy,</span><br><span class="line">                       is_alive, keep_alive, complete_gc);</span><br><span class="line">      &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该阶段的主要目的就是当内存足够时，将对应的SoftReference从refs_list中移除。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ReferenceProcessor::process_phase1(DiscoveredList&amp;    refs_list,</span><br><span class="line">                                   ReferencePolicy*   policy,</span><br><span class="line">                                   BoolObjectClosure* is_alive,</span><br><span class="line">                                   OopClosure*        keep_alive,</span><br><span class="line">                                   VoidClosure*       complete_gc) &#123;</span><br><span class="line">  </span><br><span class="line">  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);</span><br><span class="line">  <span class="comment">// Decide which softly reachable refs should be kept alive.</span></span><br><span class="line">  <span class="keyword">while</span> (iter.has_next()) &#123;</span><br><span class="line">    iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() <span class="comment">/* allow_null_referent */</span>));</span><br><span class="line">    <span class="comment">//判断引用的对象是否存活</span></span><br><span class="line">    bool referent_is_dead = (iter.referent() != NULL) &amp;&amp; !iter.is_referent_alive();</span><br><span class="line">    <span class="comment">//如果引用的对象已经不存活了，则会去调用对应的ReferencePolicy判断该对象是不时要被回收</span></span><br><span class="line">    <span class="keyword">if</span> (referent_is_dead &amp;&amp;</span><br><span class="line">        !policy-&gt;should_clear_reference(iter.obj(), _soft_ref_timestamp_clock)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (TraceReferenceGC) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print_cr(<span class="string">&quot;Dropping reference (&quot;</span> INTPTR_FORMAT <span class="string">&quot;: %s&quot;</span>  <span class="string">&quot;) by policy&quot;</span>,</span><br><span class="line">                               (<span class="keyword">void</span> *)iter.obj(), iter.obj()-&gt;klass()-&gt;internal_name());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Remove Reference object from list</span></span><br><span class="line">      iter.remove();</span><br><span class="line">      <span class="comment">// Make the Reference object active again</span></span><br><span class="line">      iter.make_active();</span><br><span class="line">      <span class="comment">// keep the referent around</span></span><br><span class="line">      iter.make_referent_alive();</span><br><span class="line">      iter.move_to_next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>process_discovered_reflist处理refList，判断当这个对象已经死掉且不需要删除引用时，会把这个reference从list里面删除。也就是说，留在list里面的都是需要进行gc的对象。<br>Policy一共有4种实现：</p>
<ul>
<li>NeverClearPolicy</li>
<li>AlwaysClearPolicy</li>
<li>LRUCurrentHeapPolicy</li>
<li>LRUMaxHeapPolicy</li>
</ul>
<p>前两种很直观略过不谈，看后两种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool LRUMaxHeapPolicy::should_clear_reference(oop p,</span><br><span class="line">                                             jlong timestamp_clock) &#123;</span><br><span class="line">  jlong interval = timestamp_clock - java_lang_ref_SoftReference::timestamp(p);</span><br><span class="line">  assert(interval &gt;= <span class="number">0</span>, <span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The interval will be zero if the ref was accessed since the last scavenge/gc.</span></span><br><span class="line">  <span class="keyword">if</span>(interval &lt;= _max_interval) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LRUCurrentHeapPolicy::setup() &#123;</span><br><span class="line">  _max_interval = (Universe::get_heap_free_at_last_gc() / M) * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  assert(_max_interval &gt;= <span class="number">0</span>,<span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRUMaxHeapPolicy::setup() &#123;</span><br><span class="line">  size_t max_heap = MaxHeapSize;</span><br><span class="line">  max_heap -= Universe::get_heap_used_at_last_gc();</span><br><span class="line">  max_heap /= M;</span><br><span class="line"></span><br><span class="line">  _max_interval = max_heap * SoftRefLRUPolicyMSPerMB;</span><br><span class="line">  assert(_max_interval &gt;= <span class="number">0</span>,<span class="string">&quot;Sanity check&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timestamp_clock是上文中的静态域clock，java_lang_ref_SoftReference::timestamp(p)是timestamp，这个差值当gc后调用get时为0，否则为多次gc的后与调用get()之间的差值。<br>max_interval 是一个是否要gc的临界值，根据LRUCurrentHeapPolicy或者LRUMaxHeapPolicy两种策略有不同的取值逻辑。<br>所以SoftReference的回收机制跟下面三种因素有关:</p>
<ul>
<li>ReferencePolicy</li>
<li>上次gc与get()方法的时间差值</li>
<li>堆可用内存</li>
</ul>
<h1 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new weak reference that refers to the given object.  The new</span></span><br><span class="line"><span class="comment">     * reference is not registered with any queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public WeakReference(T referent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new weak reference that refers to the given object and is</span></span><br><span class="line"><span class="comment">     * registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public WeakReference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q) &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WeakReference的代码没有任何可看的内容，还是看上文提到的process_discovered_reflist方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">ReferenceProcessor::process_discovered_reflist(</span><br><span class="line">  DiscoveredList               refs_lists[],</span><br><span class="line">  ReferencePolicy*             policy,</span><br><span class="line">  bool                         clear_referent,</span><br><span class="line">  BoolObjectClosure*           is_alive,</span><br><span class="line">  OopClosure*                  keep_alive,</span><br><span class="line">  VoidClosure*                 complete_gc,</span><br><span class="line">  AbstractRefProcTaskExecutor* task_executor)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Phase 1:将所有不存活但是还不能被回收的软引用从refs_lists中移除（只有refs_lists为软引用的时候，这里policy才不为null）</span></span><br><span class="line">  <span class="keyword">if</span> (policy != NULL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">      RefProcPhase1Task phase1(*<span class="built_in">this</span>, refs_lists, policy, <span class="literal">true</span> <span class="comment">/*marks_oops_alive*/</span>);</span><br><span class="line">      task_executor-&gt;execute(phase1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">        process_phase1(refs_lists[i], policy,</span><br><span class="line">                       is_alive, keep_alive, complete_gc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// policy == NULL</span></span><br><span class="line">    assert(refs_lists != _discoveredSoftRefs,</span><br><span class="line">           <span class="string">&quot;Policy must be specified for soft references.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phase 2:</span></span><br><span class="line">  <span class="comment">// 移除所有指向对象还存活的引用</span></span><br><span class="line">  <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">    RefProcPhase2Task phase2(*<span class="built_in">this</span>, refs_lists, !discovery_is_atomic() <span class="comment">/*marks_oops_alive*/</span>);</span><br><span class="line">    task_executor-&gt;execute(phase2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">      process_phase2(refs_lists[i], is_alive, keep_alive, complete_gc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phase 3:</span></span><br><span class="line">  <span class="comment">// 根据clear_referent的值决定是否将不存活对象回收</span></span><br><span class="line">  <span class="keyword">if</span> (mt_processing) &#123;</span><br><span class="line">    RefProcPhase3Task phase3(*<span class="built_in">this</span>, refs_lists, clear_referent, <span class="literal">true</span> <span class="comment">/*marks_oops_alive*/</span>);</span><br><span class="line">    task_executor-&gt;execute(phase3);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; _max_num_q; i++) &#123;</span><br><span class="line">      process_phase3(refs_lists[i], clear_referent,</span><br><span class="line">                     is_alive, keep_alive, complete_gc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total_list_count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ReferenceProcessor::process_phase3(DiscoveredList&amp;    refs_list,</span><br><span class="line">                                   bool               clear_referent,</span><br><span class="line">                                   BoolObjectClosure* is_alive,</span><br><span class="line">                                   OopClosure*        keep_alive,</span><br><span class="line">                                   VoidClosure*       complete_gc) &#123;</span><br><span class="line">  ResourceMark rm;</span><br><span class="line">  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);</span><br><span class="line">  <span class="keyword">while</span> (iter.has_next()) &#123;</span><br><span class="line">    iter.update_discovered();</span><br><span class="line">    iter.load_ptrs(DEBUG_ONLY(<span class="literal">false</span> <span class="comment">/* allow_null_referent */</span>));</span><br><span class="line">    <span class="keyword">if</span> (clear_referent) &#123;</span><br><span class="line">      <span class="comment">// NULL out referent pointer</span></span><br><span class="line">      <span class="comment">//将Reference的referent字段置为null，之后会被GC回收</span></span><br><span class="line">      iter.clear_referent();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// keep the referent around</span></span><br><span class="line">      <span class="comment">//标记引用的对象为存活，该对象在这次GC将不会被回收</span></span><br><span class="line">      iter.make_referent_alive();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是弱引用还是其他引用类型，将字段referent置null的操作都发生在process_phase3中，而具体行为是由clear_referent的值决定的。而clear_referent的值则和引用类型相关。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ReferenceProcessorStats ReferenceProcessor::process_discovered_references(</span><br><span class="line">  BoolObjectClosure*           is_alive,</span><br><span class="line">  OopClosure*                  keep_alive,</span><br><span class="line">  VoidClosure*                 complete_gc,</span><br><span class="line">  AbstractRefProcTaskExecutor* task_executor,</span><br><span class="line">  GCTimer*                     gc_timer) &#123;</span><br><span class="line">  NOT_PRODUCT(verify_ok_to_handle_reflists());</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">//process_discovered_reflist方法的第3个字段就是clear_referent</span></span><br><span class="line">  <span class="comment">// Soft references</span></span><br><span class="line">  size_t soft_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    GCTraceTime tt(<span class="string">&quot;SoftReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer);</span><br><span class="line">    soft_count =</span><br><span class="line">      process_discovered_reflist(_discoveredSoftRefs, _current_soft_ref_policy, <span class="literal">true</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update_soft_ref_master_clock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Weak references</span></span><br><span class="line">  size_t weak_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    GCTraceTime tt(<span class="string">&quot;WeakReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer);</span><br><span class="line">    weak_count =</span><br><span class="line">      process_discovered_reflist(_discoveredWeakRefs, NULL, <span class="literal">true</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Final references</span></span><br><span class="line">  size_t final_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    GCTraceTime tt(<span class="string">&quot;FinalReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer);</span><br><span class="line">    final_count =</span><br><span class="line">      process_discovered_reflist(_discoveredFinalRefs, NULL, <span class="literal">false</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Phantom references</span></span><br><span class="line">  size_t phantom_count = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    GCTraceTime tt(<span class="string">&quot;PhantomReference&quot;</span>, trace_time, <span class="literal">false</span>, gc_timer);</span><br><span class="line">    phantom_count =</span><br><span class="line">      process_discovered_reflist(_discoveredPhantomRefs, NULL, <span class="literal">false</span>,</span><br><span class="line">                                 is_alive, keep_alive, complete_gc, task_executor);</span><br><span class="line">  &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于Soft references和Weak references clear_referent字段传入的都是true，这也符合我们的预期：对象不可达后，引用字段就会被置为null，然后对象就会被回收（对于软引用来说，如果内存足够的话，在Phase 1，相关的引用就会从refs_list中被移除，到Phase 3时refs_list为空集合）。<br>但对于Final references和 Phantom references，clear_referent字段传入的是false，也就意味着被这两种引用类型引用的对象，如果没有其他额外处理，只要Reference对象还存活，那引用的对象是不会被回收的。接下来看看Phantom references。</p>
<h1 id="PhantomReference"><a href="#PhantomReference" class="headerlink" title="PhantomReference"></a>PhantomReference</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class="line"><span class="comment">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return  </span>&lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public T get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new phantom reference that refers to the given object and</span></span><br><span class="line"><span class="comment">     * is registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * method will always return null and, since it does not have a queue, it</span></span><br><span class="line"><span class="comment">     * will never be enqueued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>referent the object the new phantom reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public PhantomReference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q) &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚引用的get()永远返回null，而PhantomReference指向的对象，如果不使用clear解除虚引用的话，这个对象是永远不会回收的。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>总结一下Java的引用类型：</p>
<ol>
<li>软引用的对象回收策略与引用对象get()的时间、堆内存大的大小、ReferencePolicy都有关系。</li>
<li>虚引用并非不会影响对象的生命周期，如果不做任何处理，被虚引用指向的对象永远不会被gc。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/18/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3MySQL%E7%9A%84sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roger Meng">
      <meta itemprop="description" content="给我点学习的动力">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="怒吃树的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/18/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3MySQL%E7%9A%84sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">简单理解MySQL的sql查询执行过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-18 17:22:34" itemprop="dateCreated datePublished" datetime="2019-09-18T17:22:34+08:00">2019-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 19:38:11" itemprop="dateModified" datetime="2020-10-08T19:38:11+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>日常工作中一般我们都需要和DB打交道，作为一个有强迫症的工程师（我认为也是成为优秀工程师的必要特质），我本人是非常想知道我写的每个sql，它的实际性能如何？在实现基本业务需求的前提下，它是不是各种实现方式的最优解？想知道这些，你当然需要知道一条sql语句在实际执行过程中是如何被解析并运行返回结果的。最近也读了些文章和订阅的专栏来了解这方面知识，这篇文章作为一个开篇来简单谈谈我的理解。</p>
<h1 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h1><p><img src="https://myblog-1259548259.cos.ap-beijing.myqcloud.com/mysql_framework.png" alt="MySQL逻辑架构" title="MySQL逻辑架构"><br>这个架构我是摘自极客时间丁奇的一个订阅付费的专栏，专门介绍mysql的，我觉得讲的蛮好，大家有兴趣也可以读读。<br>Mysql从大块上来划分，主要就是Server层和存储层。Server层又可以拆解成连接器、分析器、优化器和执行器，下面依次谈下我对这几个组件的理解。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>这个组件的主要作用是和客户端进行交互，完成权限验证操作（如我们的每次登陆mysql -h -u -p，连接器会去user表中查询输入的用户名密码是否有效)。<br>在完成登陆操作后，客户端和MySQL Server的一条连接就成功建立了（TCP握手）。连接后如果没有后续的CRUD，那么这个连接就是空闲状态，通常这个连接不会一直保持，超过一定时间，连接器就会自动将它断开。这个时间默认是8小时。<br>数据库连接可以分为长连接和短连接。长连接指客户端持续的请求一直使用同一个连接，短连接指请求执行短时间的一个或几个查询后就断开连接。数据库连接的建立是一个非常耗时的操作，理论上使用长连接能获得更好的查询性能，但长连接也会存在问题，我在这里引用丁奇专栏里的内容，感觉讲的还比较清楚：</p>
<blockquote>
<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存飙升，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源在连接断开时会得到释放。长连接积累下来，可能导致内存占用太大，被系统强行杀掉，从现象看就是MySQL异常重启了。<br>解决这个问题有两个方案：</p>
<ol>
<li>定期断开长连接。</li>
<li>MySQL5.7以上的版本，可以执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和权限验证，但会将连接恢复到刚刚创建时的状态。</li>
</ol>
</blockquote>
<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>词法分析&amp;语法分析，如识别”select * from t1 where id = 1*”中的select是一个查询语句，from后面的t1是一个表名等等。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器主要用于决定命中索引以及多表join时各个表的连接顺序。</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器是Server与存储引擎交互的部分，MySQL的存储引擎是类似插件式的实现方式，不同的存储引擎只需对Server层暴露对应的api即可。执行的步骤以上述sql为例，就是不断调用对应引擎的接口获得表的第n行，判断该行的id是否为1，是则存储到结果集，遍历完成后将结果集返回给客户端即可。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>简单总结下一条sql查询的执行过程：</p>
<ol>
<li>客户端发送一条sql查询语句</li>
<li>Server层判断缓存中是否存在对应sql的key，是则直接返回结果给客户端，否则继续执行</li>
<li>Server调用分析器进行词法&amp;语法分析，对于不满足语法条件的sql语句直接抛出异常返回给客户端</li>
<li>Server调用优化器来决定使用的索引以及多表关联的顺序</li>
<li>Server调用执行器去存储引擎查找数据，将符合查询条件的数据返回给客户端</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Roger Meng</p>
  <div class="site-description" itemprop="description">给我点学习的动力</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger Meng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
